package com.viagraphs.idb

import monifu.concurrent.Scheduler
import monifu.reactive.Ack.Continue
import monifu.reactive.{Ack, Observer, Observable}
import org.scalajs.dom._
import upickle.Aliases._
import upickle._
import monifu.reactive.internals.FutureAckExtensions
import scala.annotation.implicitNotFound
import scala.collection.mutable.ArrayBuffer
import scala.concurrent.Future
import scala.scalajs.js
import scala.util.control.NonFatal
import scala.language.higherKinds

/**
 * Type Class that puts a view bound on key types. Value types are not restricted much so I don't handle that
 */
@implicitNotFound("No implicit ValidKey defined for ${T}, thus it is not a valid Store Key type")
sealed trait ValidKey[T]
object ValidKey {
  implicit object StringOk extends ValidKey[String]
  implicit object IntOk extends ValidKey[Int]
  implicit object IntSeqOk extends ValidKey[Seq[Int]]
  implicit object IntArrayOk extends ValidKey[Array[Int]]
  implicit object StringSeqOk extends ValidKey[Seq[String]]
  implicit object StringArrayOk extends ValidKey[Array[String]]
  implicit object JsDateOk extends ValidKey[js.Date]
}

abstract class TypeClasses[K : W : R : ValidKey, V : W : R] {

  def underlying: Observable[IDBDatabase]
  def storeName: String

  /**
   * Request is an observable of Output/results
   * @param input an [[Iterable]] or [[Key]] of keys or values transaction is created over
   * @param tx transaction strategy for either [[Iterable]] or [[Key]]
   */
  abstract class Request[I, O, C[_]](val input: C[I], tx: Tx[C]) extends Observable[O] {
    def txAccess: TxAccess
    def execute(store: IDBObjectStore, input: Either[I, Key[I]]): IDBRequest
    def onSuccess(result: Either[(I, Any), IDBCursorWithValue], observer: Observer[O]): Future[Ack]
    def onError(input: Option[I] = None): String
    def subscribeFn(observer: Observer[O]): Unit = {
      import scala.scalajs.js.JSConverters._
      underlying.foreachWith(observer) { db =>
        val transaction = db.transaction(txAccess.storeNames.toJSArray, txAccess.value)
        tx.execute[I, O](this, transaction, observer)
      }(db => s"Unable to open transaction for request $this")
    }
  }

  /**
   * IDB is requested by providing store keys as scala [[Iterable]] or this [[Key]].
   * As [[Iterable]] is a type constructor, [[Key]] must have become type constructor too to make abstraction over both
   */
  sealed trait Key[_] {
    def range: IDBKeyRange
    def direction: Direction
  }
  case class rangedKey(range: IDBKeyRange, direction: Direction) extends Key[K]
  case object lastKey extends Key[K] {
    def range: IDBKeyRange = null
    def direction: Direction = Direction.Prev
  }
  case object firstKey extends Key[K] {
    def range: IDBKeyRange = null
    def direction: Direction = Direction.Next
  }

  /**
   * Type class representing an abstraction over store's ability having key on keypath or autogenerated
   * @tparam I either [[K]] or [[(K,V)]]
   */
  @implicitNotFound("No implicit StoreKeyPolicy defined for ${I}, only V or (K,V) types are supported")
  trait StoreKeyPolicy[I] {
    def add(input: I, store: IDBObjectStore): IDBRequest
    def put(input: I, store: IDBObjectStore): IDBRequest
    def value(input: I): V
  }
  object StoreKeyPolicy {
    implicit object implicitly extends StoreKeyPolicy[V] {
      def value(input: V): V = input
      def add(input: V, store: IDBObjectStore): IDBRequest = {
        store.add(json.writeJs(writeJs[V](input)).asInstanceOf[js.Any])
      }
      def put(input: V, store: IDBObjectStore): IDBRequest = {
        store.put(json.writeJs(writeJs[V](input)).asInstanceOf[js.Any])
      }
    }
    implicit object explicitly extends StoreKeyPolicy[(K,V)] {
      def value(input: (K,V)): V = input._2
      def add(input: (K,V), store: IDBObjectStore): IDBRequest = {
        store.add(
          json.writeJs(writeJs[V](input._2)).asInstanceOf[js.Any],
          json.writeJs(writeJs[K](input._1)).asInstanceOf[js.Any]
        )
      }
      def put(input: (K,V), store: IDBObjectStore): IDBRequest = {
        store.put(
          json.writeJs(writeJs[V](input._2)).asInstanceOf[js.Any],
          json.writeJs(writeJs[K](input._1)).asInstanceOf[js.Any]
        )
      }
    }
  }

  /**
   * Type class representing a transaction strategy over request input that is either [[Iterable]] or [[Key]]
   * @tparam C either [[Iterable]] or [[Key]] type constructor
   */
  @implicitNotFound("No implicit Tx defined for ${C}, only [[Key]] and [[Iterable]] types are supported")
  abstract class Tx[C[_]] {
    def execute[I, O](request: Request[I, O, C], tx: IDBTransaction, observer: Observer[O]): Unit
  }

  object Tx {
    implicit def iterable[C[X] <: Iterable[X]]: Tx[C] = new Tx[C] {
      override def execute[I,O](request: Request[I, O, C], tx: IDBTransaction, observer: Observer[O]): Unit = {
        val store = tx.objectStore(storeName)
        def >>(it: Iterator[I]): Unit = {
          if (it.hasNext) {
            val next = it.next()
            try {
              val req = request.execute(store, Left(next))
              req.onsuccess = (e: Event) => {
                request.onSuccess(Left(next, req.result), observer).onCompleteNow {
                  case Continue.IsSuccess =>
                    >>(it)
                  case _ =>
                }(IndexedDb.scheduler)
              }
              req.onerror = (e: ErrorEvent) => {
                observer.onError(new IDbRequestException(request.onError(Some(next)), req.error))
              }
            } catch {
              case NonFatal(ex) =>
                observer.onError(new IDbException(request.onError(Some(next)), ex))
            }
          }
        }
        val it = request.input.iterator
        if (it.hasNext) {
          tx.oncomplete = (e: Event) => {
            observer.onComplete()
          }
          tx.onerror = (e: ErrorEvent) => {
            observer.onError(new IDbTxException(request.onError(), tx.error))
          }
          >>(it)
        } else {
          observer.onComplete()
        }
      }
    }
    implicit def range[C[X] <: Key[X]]: Tx[C] = new Tx[C] {
      override def execute[I, O](request: Request[I, O, C], tx: IDBTransaction, observer: Observer[O]): Unit = {
        val store = tx.objectStore(storeName)
        val keyRange = request.input
        try {
          val req = request.execute(store, Right(keyRange))
          req.onsuccess = (e: Event) => {
            e.target.asInstanceOf[IDBRequest].result match {
              case cursor: IDBCursorWithValue =>
                request.onSuccess(Right(cursor), observer).onCompleteNow {
                  case Continue.IsSuccess if keyRange.isInstanceOf[rangedKey] =>
                    cursor.continue()
                  case _ =>
                }(IndexedDb.scheduler)
              case _ => // rangedKey sequence ended
            }
          }
          req.onerror = (e: ErrorEvent) => {
            observer.onError(new IDbRequestException(request.onError(), req.error))
          }
          tx.oncomplete = (e: Event) => {
            observer.onComplete()
          }
          tx.onerror = (e: ErrorEvent) => {
            observer.onError(new IDbTxException(request.onError(), tx.error))
          }
        } catch {
          case NonFatal(ex) =>
            observer.onError(new IDbException(request.onError(), ex))
        }
      }
    }
  }
}

object TypeClasses {
  import scala.collection.immutable.TreeMap
  implicit def TreeMapW[K: W : Ordering, V: W]: W[TreeMap[K, V]] = W[TreeMap[K, V]](
    x => Js.Arr(x.toSeq.map(writeJs[(K, V)]): _*)
  )
  implicit def TreeMapR[K: R : Ordering, V: R]: R[TreeMap[K, V]] = R[TreeMap[K, V]](
    Internal.validate("Array(n)") {
      case x: Js.Arr => TreeMap(x.value.map(readJs[(K, V)]): _*)
    }
  )
  implicit class RequestPimp[+E](observable: Observable[E]) {
    def flatMapOnComplete[U](f: Seq[E] => Observable[U]): Observable[U] = {
      def emptyYieldingBuffer[T](source: Observable[T], count: Int)(implicit s: Scheduler): Observable[Seq[T]] =
        Observable.create { observer =>
          source.unsafeSubscribe(new Observer[T] {
            private[this] var buffer = ArrayBuffer.empty[T]
            private[this] var lastAck = Continue : Future[Ack]
            private[this] var size = 0

            def onNext(elem: T): Future[Ack] = {
              size += 1
              buffer.append(elem)
              if (size >= count) {
                val oldBuffer = buffer
                buffer = ArrayBuffer.empty[T]
                size = 0

                lastAck = observer.onNext(oldBuffer)
                lastAck
              }
              else
                Continue
            }

            def onError(ex: Throwable): Unit = {
              observer.onError(ex)
              buffer = null
            }

            def onComplete(): Unit = {
              lastAck.onContinueCompleteWith(observer, buffer)
              buffer = null
            }
          })
        }
      flatMapOnComplete(emptyYieldingBuffer(observable, Integer.MAX_VALUE)(IndexedDb.scheduler).map(f))
    }

    private def flatMapOnComplete[U, T](source: Observable[T])(implicit ev: T <:< Observable[U]): Observable[U] = {
      Observable.create[U] { observerU =>
        source.unsafeSubscribe(new Observer[T] {
          private[this] var childObservable: T = _

          def onNext(elem: T) = {
            childObservable = elem
            Continue
          }

          def onError(ex: Throwable) = {
            observerU.onError(ex)
          }

          def onComplete() = {
            Option(childObservable).fold(observerU.onComplete()) { obs =>
              obs.unsafeSubscribe(new Observer[U] {
                def onNext(elem: U) = {
                  observerU.onNext(elem)
                }

                def onError(ex: Throwable): Unit = {
                  observerU.onError(ex)
                }

                def onComplete(): Unit = {
                  observerU.onComplete()
                }
              })
            }
          }
        })
      }
    }
  }
}